// Code generated by counterfeiter. DO NOT EDIT.
package handlersfakes

import (
	"context"
	"sync"

	"github.com/jivvon/node-label-controller/api/v1alpha1"
	"github.com/jivvon/node-label-controller/internal/controller/handlers"
	v1 "k8s.io/api/core/v1"
)

type FakeNodeLabelPolicyHandler struct {
	ApplyLabelsToNodeStub        func(context.Context, *v1.Node, map[string]string, string) error
	applyLabelsToNodeMutex       sync.RWMutex
	applyLabelsToNodeArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.Node
		arg3 map[string]string
		arg4 string
	}
	applyLabelsToNodeReturns struct {
		result1 error
	}
	applyLabelsToNodeReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupLabelsFromAllNodesStub        func(context.Context, string, map[string]string) error
	cleanupLabelsFromAllNodesMutex       sync.RWMutex
	cleanupLabelsFromAllNodesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]string
	}
	cleanupLabelsFromAllNodesReturns struct {
		result1 error
	}
	cleanupLabelsFromAllNodesReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveLabelsFromUnselectedNodesStub        func(context.Context, []v1.Node, []v1.Node, string, map[string]string) error
	removeLabelsFromUnselectedNodesMutex       sync.RWMutex
	removeLabelsFromUnselectedNodesArgsForCall []struct {
		arg1 context.Context
		arg2 []v1.Node
		arg3 []v1.Node
		arg4 string
		arg5 map[string]string
	}
	removeLabelsFromUnselectedNodesReturns struct {
		result1 error
	}
	removeLabelsFromUnselectedNodesReturnsOnCall map[int]struct {
		result1 error
	}
	SelectNodesStub        func(context.Context, []v1.Node, v1alpha1.NodeLabelPolicyStrategy) ([]v1.Node, error)
	selectNodesMutex       sync.RWMutex
	selectNodesArgsForCall []struct {
		arg1 context.Context
		arg2 []v1.Node
		arg3 v1alpha1.NodeLabelPolicyStrategy
	}
	selectNodesReturns struct {
		result1 []v1.Node
		result2 error
	}
	selectNodesReturnsOnCall map[int]struct {
		result1 []v1.Node
		result2 error
	}
	UpdatePolicyStatusStub        func(context.Context, *v1alpha1.NodeLabelPolicy, []string) error
	updatePolicyStatusMutex       sync.RWMutex
	updatePolicyStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.NodeLabelPolicy
		arg3 []string
	}
	updatePolicyStatusReturns struct {
		result1 error
	}
	updatePolicyStatusReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeLabelPolicyHandler) ApplyLabelsToNode(arg1 context.Context, arg2 *v1.Node, arg3 map[string]string, arg4 string) error {
	fake.applyLabelsToNodeMutex.Lock()
	ret, specificReturn := fake.applyLabelsToNodeReturnsOnCall[len(fake.applyLabelsToNodeArgsForCall)]
	fake.applyLabelsToNodeArgsForCall = append(fake.applyLabelsToNodeArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.Node
		arg3 map[string]string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ApplyLabelsToNodeStub
	fakeReturns := fake.applyLabelsToNodeReturns
	fake.recordInvocation("ApplyLabelsToNode", []interface{}{arg1, arg2, arg3, arg4})
	fake.applyLabelsToNodeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeLabelPolicyHandler) ApplyLabelsToNodeCallCount() int {
	fake.applyLabelsToNodeMutex.RLock()
	defer fake.applyLabelsToNodeMutex.RUnlock()
	return len(fake.applyLabelsToNodeArgsForCall)
}

func (fake *FakeNodeLabelPolicyHandler) ApplyLabelsToNodeCalls(stub func(context.Context, *v1.Node, map[string]string, string) error) {
	fake.applyLabelsToNodeMutex.Lock()
	defer fake.applyLabelsToNodeMutex.Unlock()
	fake.ApplyLabelsToNodeStub = stub
}

func (fake *FakeNodeLabelPolicyHandler) ApplyLabelsToNodeArgsForCall(i int) (context.Context, *v1.Node, map[string]string, string) {
	fake.applyLabelsToNodeMutex.RLock()
	defer fake.applyLabelsToNodeMutex.RUnlock()
	argsForCall := fake.applyLabelsToNodeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNodeLabelPolicyHandler) ApplyLabelsToNodeReturns(result1 error) {
	fake.applyLabelsToNodeMutex.Lock()
	defer fake.applyLabelsToNodeMutex.Unlock()
	fake.ApplyLabelsToNodeStub = nil
	fake.applyLabelsToNodeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) ApplyLabelsToNodeReturnsOnCall(i int, result1 error) {
	fake.applyLabelsToNodeMutex.Lock()
	defer fake.applyLabelsToNodeMutex.Unlock()
	fake.ApplyLabelsToNodeStub = nil
	if fake.applyLabelsToNodeReturnsOnCall == nil {
		fake.applyLabelsToNodeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyLabelsToNodeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) CleanupLabelsFromAllNodes(arg1 context.Context, arg2 string, arg3 map[string]string) error {
	fake.cleanupLabelsFromAllNodesMutex.Lock()
	ret, specificReturn := fake.cleanupLabelsFromAllNodesReturnsOnCall[len(fake.cleanupLabelsFromAllNodesArgsForCall)]
	fake.cleanupLabelsFromAllNodesArgsForCall = append(fake.cleanupLabelsFromAllNodesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]string
	}{arg1, arg2, arg3})
	stub := fake.CleanupLabelsFromAllNodesStub
	fakeReturns := fake.cleanupLabelsFromAllNodesReturns
	fake.recordInvocation("CleanupLabelsFromAllNodes", []interface{}{arg1, arg2, arg3})
	fake.cleanupLabelsFromAllNodesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeLabelPolicyHandler) CleanupLabelsFromAllNodesCallCount() int {
	fake.cleanupLabelsFromAllNodesMutex.RLock()
	defer fake.cleanupLabelsFromAllNodesMutex.RUnlock()
	return len(fake.cleanupLabelsFromAllNodesArgsForCall)
}

func (fake *FakeNodeLabelPolicyHandler) CleanupLabelsFromAllNodesCalls(stub func(context.Context, string, map[string]string) error) {
	fake.cleanupLabelsFromAllNodesMutex.Lock()
	defer fake.cleanupLabelsFromAllNodesMutex.Unlock()
	fake.CleanupLabelsFromAllNodesStub = stub
}

func (fake *FakeNodeLabelPolicyHandler) CleanupLabelsFromAllNodesArgsForCall(i int) (context.Context, string, map[string]string) {
	fake.cleanupLabelsFromAllNodesMutex.RLock()
	defer fake.cleanupLabelsFromAllNodesMutex.RUnlock()
	argsForCall := fake.cleanupLabelsFromAllNodesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNodeLabelPolicyHandler) CleanupLabelsFromAllNodesReturns(result1 error) {
	fake.cleanupLabelsFromAllNodesMutex.Lock()
	defer fake.cleanupLabelsFromAllNodesMutex.Unlock()
	fake.CleanupLabelsFromAllNodesStub = nil
	fake.cleanupLabelsFromAllNodesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) CleanupLabelsFromAllNodesReturnsOnCall(i int, result1 error) {
	fake.cleanupLabelsFromAllNodesMutex.Lock()
	defer fake.cleanupLabelsFromAllNodesMutex.Unlock()
	fake.CleanupLabelsFromAllNodesStub = nil
	if fake.cleanupLabelsFromAllNodesReturnsOnCall == nil {
		fake.cleanupLabelsFromAllNodesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupLabelsFromAllNodesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) RemoveLabelsFromUnselectedNodes(arg1 context.Context, arg2 []v1.Node, arg3 []v1.Node, arg4 string, arg5 map[string]string) error {
	var arg2Copy []v1.Node
	if arg2 != nil {
		arg2Copy = make([]v1.Node, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []v1.Node
	if arg3 != nil {
		arg3Copy = make([]v1.Node, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.removeLabelsFromUnselectedNodesMutex.Lock()
	ret, specificReturn := fake.removeLabelsFromUnselectedNodesReturnsOnCall[len(fake.removeLabelsFromUnselectedNodesArgsForCall)]
	fake.removeLabelsFromUnselectedNodesArgsForCall = append(fake.removeLabelsFromUnselectedNodesArgsForCall, struct {
		arg1 context.Context
		arg2 []v1.Node
		arg3 []v1.Node
		arg4 string
		arg5 map[string]string
	}{arg1, arg2Copy, arg3Copy, arg4, arg5})
	stub := fake.RemoveLabelsFromUnselectedNodesStub
	fakeReturns := fake.removeLabelsFromUnselectedNodesReturns
	fake.recordInvocation("RemoveLabelsFromUnselectedNodes", []interface{}{arg1, arg2Copy, arg3Copy, arg4, arg5})
	fake.removeLabelsFromUnselectedNodesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeLabelPolicyHandler) RemoveLabelsFromUnselectedNodesCallCount() int {
	fake.removeLabelsFromUnselectedNodesMutex.RLock()
	defer fake.removeLabelsFromUnselectedNodesMutex.RUnlock()
	return len(fake.removeLabelsFromUnselectedNodesArgsForCall)
}

func (fake *FakeNodeLabelPolicyHandler) RemoveLabelsFromUnselectedNodesCalls(stub func(context.Context, []v1.Node, []v1.Node, string, map[string]string) error) {
	fake.removeLabelsFromUnselectedNodesMutex.Lock()
	defer fake.removeLabelsFromUnselectedNodesMutex.Unlock()
	fake.RemoveLabelsFromUnselectedNodesStub = stub
}

func (fake *FakeNodeLabelPolicyHandler) RemoveLabelsFromUnselectedNodesArgsForCall(i int) (context.Context, []v1.Node, []v1.Node, string, map[string]string) {
	fake.removeLabelsFromUnselectedNodesMutex.RLock()
	defer fake.removeLabelsFromUnselectedNodesMutex.RUnlock()
	argsForCall := fake.removeLabelsFromUnselectedNodesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeNodeLabelPolicyHandler) RemoveLabelsFromUnselectedNodesReturns(result1 error) {
	fake.removeLabelsFromUnselectedNodesMutex.Lock()
	defer fake.removeLabelsFromUnselectedNodesMutex.Unlock()
	fake.RemoveLabelsFromUnselectedNodesStub = nil
	fake.removeLabelsFromUnselectedNodesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) RemoveLabelsFromUnselectedNodesReturnsOnCall(i int, result1 error) {
	fake.removeLabelsFromUnselectedNodesMutex.Lock()
	defer fake.removeLabelsFromUnselectedNodesMutex.Unlock()
	fake.RemoveLabelsFromUnselectedNodesStub = nil
	if fake.removeLabelsFromUnselectedNodesReturnsOnCall == nil {
		fake.removeLabelsFromUnselectedNodesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeLabelsFromUnselectedNodesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) SelectNodes(arg1 context.Context, arg2 []v1.Node, arg3 v1alpha1.NodeLabelPolicyStrategy) ([]v1.Node, error) {
	var arg2Copy []v1.Node
	if arg2 != nil {
		arg2Copy = make([]v1.Node, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.selectNodesMutex.Lock()
	ret, specificReturn := fake.selectNodesReturnsOnCall[len(fake.selectNodesArgsForCall)]
	fake.selectNodesArgsForCall = append(fake.selectNodesArgsForCall, struct {
		arg1 context.Context
		arg2 []v1.Node
		arg3 v1alpha1.NodeLabelPolicyStrategy
	}{arg1, arg2Copy, arg3})
	stub := fake.SelectNodesStub
	fakeReturns := fake.selectNodesReturns
	fake.recordInvocation("SelectNodes", []interface{}{arg1, arg2Copy, arg3})
	fake.selectNodesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeLabelPolicyHandler) SelectNodesCallCount() int {
	fake.selectNodesMutex.RLock()
	defer fake.selectNodesMutex.RUnlock()
	return len(fake.selectNodesArgsForCall)
}

func (fake *FakeNodeLabelPolicyHandler) SelectNodesCalls(stub func(context.Context, []v1.Node, v1alpha1.NodeLabelPolicyStrategy) ([]v1.Node, error)) {
	fake.selectNodesMutex.Lock()
	defer fake.selectNodesMutex.Unlock()
	fake.SelectNodesStub = stub
}

func (fake *FakeNodeLabelPolicyHandler) SelectNodesArgsForCall(i int) (context.Context, []v1.Node, v1alpha1.NodeLabelPolicyStrategy) {
	fake.selectNodesMutex.RLock()
	defer fake.selectNodesMutex.RUnlock()
	argsForCall := fake.selectNodesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNodeLabelPolicyHandler) SelectNodesReturns(result1 []v1.Node, result2 error) {
	fake.selectNodesMutex.Lock()
	defer fake.selectNodesMutex.Unlock()
	fake.SelectNodesStub = nil
	fake.selectNodesReturns = struct {
		result1 []v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeLabelPolicyHandler) SelectNodesReturnsOnCall(i int, result1 []v1.Node, result2 error) {
	fake.selectNodesMutex.Lock()
	defer fake.selectNodesMutex.Unlock()
	fake.SelectNodesStub = nil
	if fake.selectNodesReturnsOnCall == nil {
		fake.selectNodesReturnsOnCall = make(map[int]struct {
			result1 []v1.Node
			result2 error
		})
	}
	fake.selectNodesReturnsOnCall[i] = struct {
		result1 []v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeLabelPolicyHandler) UpdatePolicyStatus(arg1 context.Context, arg2 *v1alpha1.NodeLabelPolicy, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updatePolicyStatusMutex.Lock()
	ret, specificReturn := fake.updatePolicyStatusReturnsOnCall[len(fake.updatePolicyStatusArgsForCall)]
	fake.updatePolicyStatusArgsForCall = append(fake.updatePolicyStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.NodeLabelPolicy
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdatePolicyStatusStub
	fakeReturns := fake.updatePolicyStatusReturns
	fake.recordInvocation("UpdatePolicyStatus", []interface{}{arg1, arg2, arg3Copy})
	fake.updatePolicyStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNodeLabelPolicyHandler) UpdatePolicyStatusCallCount() int {
	fake.updatePolicyStatusMutex.RLock()
	defer fake.updatePolicyStatusMutex.RUnlock()
	return len(fake.updatePolicyStatusArgsForCall)
}

func (fake *FakeNodeLabelPolicyHandler) UpdatePolicyStatusCalls(stub func(context.Context, *v1alpha1.NodeLabelPolicy, []string) error) {
	fake.updatePolicyStatusMutex.Lock()
	defer fake.updatePolicyStatusMutex.Unlock()
	fake.UpdatePolicyStatusStub = stub
}

func (fake *FakeNodeLabelPolicyHandler) UpdatePolicyStatusArgsForCall(i int) (context.Context, *v1alpha1.NodeLabelPolicy, []string) {
	fake.updatePolicyStatusMutex.RLock()
	defer fake.updatePolicyStatusMutex.RUnlock()
	argsForCall := fake.updatePolicyStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNodeLabelPolicyHandler) UpdatePolicyStatusReturns(result1 error) {
	fake.updatePolicyStatusMutex.Lock()
	defer fake.updatePolicyStatusMutex.Unlock()
	fake.UpdatePolicyStatusStub = nil
	fake.updatePolicyStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) UpdatePolicyStatusReturnsOnCall(i int, result1 error) {
	fake.updatePolicyStatusMutex.Lock()
	defer fake.updatePolicyStatusMutex.Unlock()
	fake.UpdatePolicyStatusStub = nil
	if fake.updatePolicyStatusReturnsOnCall == nil {
		fake.updatePolicyStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePolicyStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeLabelPolicyHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyLabelsToNodeMutex.RLock()
	defer fake.applyLabelsToNodeMutex.RUnlock()
	fake.cleanupLabelsFromAllNodesMutex.RLock()
	defer fake.cleanupLabelsFromAllNodesMutex.RUnlock()
	fake.removeLabelsFromUnselectedNodesMutex.RLock()
	defer fake.removeLabelsFromUnselectedNodesMutex.RUnlock()
	fake.selectNodesMutex.RLock()
	defer fake.selectNodesMutex.RUnlock()
	fake.updatePolicyStatusMutex.RLock()
	defer fake.updatePolicyStatusMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeLabelPolicyHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ handlers.NodeLabelPolicyHandler = new(FakeNodeLabelPolicyHandler)
